# ============================================================================
# PRODUCTION DOCKERFILE FOR USASSET BACKEND
# ============================================================================
# 
# This Dockerfile implements security best practices and optimizations for
# production deployment of the USAsset NestJS backend application.
#
# Key Features:
# - Multi-stage build for minimal final image size
# - Security hardening with non-root user
# - Health checks for container orchestration
# - Proper signal handling for graceful shutdown
# - Optimized layer caching
# - Support for Prisma ORM with Alpine Linux
#
# Build Command:
#   docker build -f apps/backend/Dockerfile.production -t usasset-backend:latest .
#
# Run Command:
#   docker run -p 3000:3000 --env-file .env usasset-backend:latest
#
# ============================================================================

# ============================================================================
# STAGE 1: DEPENDENCIES
# ============================================================================
# This stage installs all dependencies needed for building the application.
# We separate this from the build stage to optimize Docker layer caching.
# ============================================================================
FROM node:20-alpine AS dependencies

# Install system dependencies required for node-gyp and Prisma
# - python3: Required for node-gyp compilation
# - make, g++: Build tools for native modules
# - openssl: Required by Prisma for database connections
RUN apk add --no-cache python3 make g++ openssl

WORKDIR /app

# Copy package files
# We copy package files first to leverage Docker cache if dependencies haven't changed
COPY package*.json ./
COPY apps/backend/package*.json ./apps/backend/

# Install ALL dependencies (including devDependencies)
# We need devDependencies for the build stage (TypeScript, NestJS CLI, etc.)
RUN npm ci

# ============================================================================
# STAGE 2: BUILDER
# ============================================================================
# This stage builds the application and generates Prisma client
# ============================================================================
FROM node:20-alpine AS builder

# Install OpenSSL for Prisma client generation
RUN apk add --no-cache openssl

WORKDIR /app

# Copy dependencies from previous stage (workspaces only have root node_modules)
COPY --from=dependencies /app/node_modules ./node_modules

# Copy package files (needed for build scripts)
COPY package*.json ./
COPY apps/backend/package*.json ./apps/backend/

# Copy source code
COPY apps/backend ./apps/backend/

# Generate Prisma client
# This creates the client in node_modules/@prisma/client
WORKDIR /app/apps/backend
RUN npx prisma generate

# Build the application
# This transpiles TypeScript to JavaScript and outputs to dist/
RUN npm run build

# ============================================================================
# STAGE 3: PRODUCTION
# ============================================================================
# This is the final stage that will be deployed to production.
# It contains only the minimal runtime dependencies and compiled code.
# ============================================================================
FROM node:20-alpine AS production

# Security: Add metadata labels
LABEL maintainer="USAsset Team"
LABEL version="1.0.0"
LABEL description="USAsset Backend API"

# Install only runtime dependencies
# - openssl: Required by Prisma at runtime
# - netcat-openbsd: Used for health checks in entrypoint
# - dumb-init: Proper signal handling and zombie reaping
RUN apk add --no-cache openssl netcat-openbsd dumb-init

# Security: Create a non-root user
# Check if group/user exists before creating
RUN (getent group nodejs || addgroup -g 1001 -S nodejs) && \
    (id -u nodejs 2>/dev/null || adduser -S nodejs -u 1001 -G nodejs)

WORKDIR /app

# Copy package files for production dependencies
COPY package*.json ./
COPY apps/backend/package*.json ./apps/backend/

# Install only production dependencies
# --omit=dev flag excludes devDependencies
RUN npm ci --omit=dev && \
    # Clean npm cache to reduce image size
    npm cache clean --force

# Copy Prisma client from builder
# The Prisma client must be copied to maintain binary compatibility
COPY --from=builder --chown=nodejs:nodejs /app/node_modules/.prisma ./node_modules/.prisma
COPY --from=builder --chown=nodejs:nodejs /app/node_modules/@prisma ./node_modules/@prisma

# Set working directory to backend
WORKDIR /app/apps/backend

# Copy built application from builder
COPY --from=builder --chown=nodejs:nodejs /app/apps/backend/dist ./dist

# Copy Prisma schema for migrations
COPY --chown=nodejs:nodejs apps/backend/prisma ./prisma

# Copy and setup entrypoint script
COPY --chown=root:root apps/backend/docker-entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh

# Security: Set proper permissions
# Ensure the nodejs user owns the app directory
RUN chown -R nodejs:nodejs /app

# Security: Switch to non-root user
USER nodejs

# Expose port (documentation only, doesn't actually open the port)
EXPOSE 3000

# Health check for container orchestration (Kubernetes, Docker Swarm, etc.)
# This allows the orchestrator to know if the container is healthy
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD node -e "require('http').get('http://localhost:3000/health', (r) => {r.statusCode === 200 ? process.exit(0) : process.exit(1)})"

# Use dumb-init to handle signals properly
# This ensures graceful shutdown and prevents zombie processes
ENTRYPOINT ["/usr/bin/dumb-init", "--", "/docker-entrypoint.sh"]

# Default command to run the application
CMD ["node", "dist/main.js"]

# ============================================================================
# SECURITY NOTES
# ============================================================================
# 
# 1. Non-root user: The container runs as user 'nodejs' (UID 1000)
# 2. Minimal attack surface: Only production dependencies installed
# 3. No shell by default: Using node directly, not npm scripts
# 4. Signal handling: dumb-init ensures proper signal propagation
# 5. Health checks: Built-in health monitoring for orchestration
# 6. Read-only filesystem compatible: App doesn't write to filesystem
#
# ============================================================================
# PERFORMANCE NOTES
# ============================================================================
#
# 1. Multi-stage build: Final image ~150MB vs ~1GB with all dependencies
# 2. Layer caching: Dependencies cached separately from code
# 3. Alpine Linux: Minimal base image for smaller size
# 4. Production mode: NODE_ENV=production optimizations enabled
#
# ============================================================================