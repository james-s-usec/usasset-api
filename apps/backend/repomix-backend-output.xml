This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*, prisma/**/*, generated/prisma/index.d.ts, generated/prisma/client.d.ts, *.json, *.md, Dockerfile, *.config.*, *.ts, *.js
- Files matching these patterns are excluded: dist/**, node_modules/**, *.log, generated/prisma/*.js, generated/prisma/runtime/**, generated/prisma/lib*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  migrations/
    20250828034338_init/
      migration.sql
    migration_lock.toml
  schema.prisma
src/
  config/
    config.factory.ts
    env.validation.spec.ts
    env.validation.ts
    logger.config.ts
  health/
    health.controller.ts
    health.module.ts
    health.repository.ts
    health.service.ts
  user/
    dto/
      create-user.dto.ts
      index.ts
      update-user.dto.ts
    enums/
      user-role.enum.ts
    interfaces/
      user.interface.ts
    user.controller.spec.ts
    user.controller.ts
    user.module.ts
    user.service.spec.ts
    user.service.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  main.ts
CLAUDE.md
Dockerfile
eslint.config.mjs
nest-cli.json
package.json
README.md
repomix.config.json
tsconfig.build.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/migrations/20250828034338_init/migration.sql">
-- CreateEnum
CREATE TYPE "public"."UserRole" AS ENUM ('USER', 'ADMIN', 'SUPER_ADMIN');

-- CreateTable
CREATE TABLE "public"."users" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "role" "public"."UserRole" NOT NULL DEFAULT 'USER',
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "public"."users"("email");
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  output        = "../generated/prisma"
  binaryTargets = ["native", "debian-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String   @id @default(uuid())
  email      String   @unique
  name       String?
  role       UserRole @default(USER)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  
  @@map("users")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}
</file>

<file path="src/config/config.factory.ts">
import { Logger } from '@nestjs/common';

export const configFactory = (): Record<string, unknown> => {
  const logger = new Logger('ConfigFactory');

  const config = {
    NODE_ENV: process.env.NODE_ENV || 'development',
    PORT: parseInt(process.env.PORT || '3000', 10),
    DATABASE_URL: process.env.DATABASE_URL,
    CORS_ORIGIN: process.env.CORS_ORIGIN || 'http://localhost:5173',
    JWT_SECRET: process.env.JWT_SECRET,
    API_KEY: process.env.API_KEY,
    LOG_TO_FILE: process.env.LOG_TO_FILE === 'true',
  };

  // Debug logging with proper logger
  logger.log('Configuration Loading');
  logger.debug(`Environment: ${config.NODE_ENV}`);
  logger.debug(`Port: ${config.PORT}`);
  logger.debug(`CORS Origin: ${config.CORS_ORIGIN}`);
  logger.debug(`Database URL: ${config.DATABASE_URL ? '[SET]' : '[NOT SET]'}`);
  logger.debug(`JWT Secret: ${config.JWT_SECRET ? '[SET]' : '[NOT SET]'}`);
  logger.debug(`API Key: ${config.API_KEY ? '[SET]' : '[NOT SET]'}`);
  logger.debug(`Log to file: ${config.LOG_TO_FILE}`);

  return config;
};
</file>

<file path="src/config/env.validation.spec.ts">
import { validationSchema } from './env.validation';

interface ValidatedConfig {
  NODE_ENV: string;
  PORT: number;
  CORS_ORIGIN: string;
  DATABASE_URL?: string;
  JWT_SECRET?: string;
  API_KEY?: string;
}

// Test data helpers
function getDevConfig(): Record<string, unknown> {
  return {
    NODE_ENV: 'development',
    PORT: 3000,
    CORS_ORIGIN: 'http://localhost:5173',
  };
}

function getProdConfig(): Record<string, unknown> {
  return {
    NODE_ENV: 'production',
    PORT: 8080,
    DATABASE_URL: 'postgresql://server.postgres.database.azure.com/usasset',
    CORS_ORIGIN: 'https://frontend.azurecontainerapps.io',
    JWT_SECRET: 'from-key-vault',
  };
}

function getAzureConfig(): Record<string, unknown> {
  return {
    NODE_ENV: 'production',
    PORT: '8080', // Azure provides PORT as string
    DATABASE_URL:
      'postgresql://dbadmin@usasset-db.postgres.database.azure.com/usasset?sslmode=require',
    CORS_ORIGIN: 'https://frontend.azurecontainerapps.io',
    JWT_SECRET: 'secretref:jwt-secret', // Key Vault reference
    API_KEY: 'secretref:api-key', // Key Vault reference
  };
}

// Validation helpers
function validateConfig(
  config: Record<string, unknown>,
): ReturnType<typeof validationSchema.validate> {
  return validationSchema.validate(config);
}

function expectValidConfig(config: Record<string, unknown>): void {
  const { error } = validateConfig(config);
  expect(error).toBeUndefined();
}

function expectInvalidConfig(
  config: Record<string, unknown>,
  expectedMessage: string,
): void {
  const { error } = validateConfig(config);
  expect(error).toBeDefined();
  expect(error?.message).toContain(expectedMessage);
}

describe('Environment Validation', () => {
  describe('Development Environment', () => {
    it('should validate development config', () => {
      expectValidConfig(getDevConfig());
    });
  });

  describe('Production Environment', () => {
    it('should validate production config with required fields', () => {
      expectValidConfig(getProdConfig());
    });

    it('should validate Azure Container Apps with Key Vault secrets', () => {
      const result = validateConfig(getAzureConfig());
      expect(result.error).toBeUndefined();
      expect((result.value as ValidatedConfig).PORT).toBe(8080);
    });

    it('should fail without DATABASE_URL in production', () => {
      const config = { NODE_ENV: 'production', JWT_SECRET: 'secret' };
      expectInvalidConfig(config, 'DATABASE_URL');
    });

    it('should fail without JWT_SECRET in production', () => {
      const config = {
        NODE_ENV: 'production',
        DATABASE_URL: 'postgresql://localhost/db',
      };
      expectInvalidConfig(config, 'JWT_SECRET');
    });
  });
});
</file>

<file path="src/config/env.validation.ts">
import * as Joi from 'joi';

export const validationSchema = Joi.object({
  // Required in all environments
  NODE_ENV: Joi.string()
    .valid('development', 'test', 'production')
    .default('development')
    .messages({
      'any.only': 'NODE_ENV must be one of: development, test, production',
    }),

  PORT: Joi.number().default(3000).messages({
    'number.base': 'PORT must be a number',
  }),

  // Required in production only
  DATABASE_URL: Joi.string().when('NODE_ENV', {
    is: 'production',
    then: Joi.required().messages({
      'any.required':
        'DATABASE_URL is required in production (should be injected from Azure Key Vault)',
    }),
    otherwise: Joi.optional(),
  }),

  CORS_ORIGIN: Joi.string().default('http://localhost:5173').messages({
    'string.base': 'CORS_ORIGIN must be a string URL',
  }),

  // Optional (for future use)
  JWT_SECRET: Joi.string().when('NODE_ENV', {
    is: 'production',
    then: Joi.required().messages({
      'any.required':
        'JWT_SECRET is required in production (should be injected from Azure Key Vault)',
    }),
    otherwise: Joi.optional().default('dev-secret'),
  }),

  API_KEY: Joi.string().optional(),
}).options({
  abortEarly: false, // Show all validation errors, not just the first one
});
</file>

<file path="src/config/logger.config.ts">
import { WinstonModule } from 'nest-winston';
import * as winston from 'winston';
import { join } from 'path';
import { LoggerService } from '@nestjs/common';

const logDir = join(process.cwd(), 'logs');

function createConsoleTransport(
  isDevelopment: boolean,
): winston.transports.ConsoleTransportInstance {
  return new winston.transports.Console({
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.errors({ stack: true }),
      isDevelopment
        ? winston.format.combine(
            winston.format.colorize(),
            winston.format.simple(),
          )
        : winston.format.json(),
    ),
  });
}

function createFileTransport(
  filename: string,
  level?: string,
): winston.transports.FileTransportInstance {
  return new winston.transports.File({
    filename: join(logDir, filename),
    level,
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.errors({ stack: true }),
      winston.format.json(),
    ),
  });
}

function shouldUseFileTransports(isDevelopment: boolean): boolean {
  return !isDevelopment || process.env.LOG_TO_FILE === 'true';
}

export const createLoggerConfig = (): LoggerService => {
  const isDevelopment = process.env.NODE_ENV !== 'production';
  const transports: winston.transport[] = [
    createConsoleTransport(isDevelopment),
  ];

  if (shouldUseFileTransports(isDevelopment)) {
    transports.push(
      createFileTransport('error.log', 'error'),
      createFileTransport('combined.log'),
    );
  }

  return WinstonModule.createLogger({
    level: isDevelopment ? 'debug' : 'info',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.errors({ stack: true }),
    ),
    transports,
  });
};
</file>

<file path="src/health/health.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { HealthService } from './health.service';

@Controller('health')
export class HealthController {
  public constructor(private readonly healthService: HealthService) {}

  @Get('ready')
  public ready(): Promise<Record<string, unknown>> {
    return this.healthService.checkReadiness();
  }

  @Get('live')
  public live(): Record<string, unknown> {
    return this.healthService.checkLiveness();
  }

  @Get()
  public check(): Record<string, unknown> {
    return this.healthService.check();
  }
}
</file>

<file path="src/health/health.module.ts">
import { Module } from '@nestjs/common';
import { HealthController } from './health.controller';
import { HealthService } from './health.service';
import { HealthRepository } from './health.repository';

@Module({
  controllers: [HealthController],
  providers: [HealthService, HealthRepository],
})
export class HealthModule {}
</file>

<file path="src/health/health.repository.ts">
import { Injectable } from '@nestjs/common';
import { PrismaClient } from '../../generated/prisma';

@Injectable()
export class HealthRepository {
  private prisma = new PrismaClient();

  public async checkDatabase(): Promise<boolean> {
    try {
      await this.prisma.$queryRaw`SELECT 1 as test`;
      return true;
    } catch {
      return false;
    }
  }

  public async onModuleDestroy(): Promise<void> {
    await this.prisma.$disconnect();
  }
}
</file>

<file path="src/health/health.service.ts">
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { HealthRepository } from './health.repository';

@Injectable()
export class HealthService {
  private startTime = Date.now();

  public constructor(
    private configService: ConfigService,
    private healthRepository: HealthRepository,
  ) {}

  public check(): Record<string, unknown> {
    return {
      status: this.getHealthStatus(),
      timestamp: new Date().toISOString(),
      uptime: this.getUptime(),
      environment: this.configService.get<string>('NODE_ENV', 'development'),
      version: this.getVersion(),
    };
  }

  public async checkReadiness(): Promise<Record<string, unknown>> {
    const basicHealth = this.check();
    const databaseStatus = await this.checkDatabase();

    return {
      ...basicHealth,
      services: {
        database: databaseStatus,
      },
    };
  }

  public checkLiveness(): Record<string, unknown> {
    return {
      status: this.getAliveStatus(),
      timestamp: new Date().toISOString(),
    };
  }

  private getHealthStatus(): string {
    return 'ok';
  }

  private getAliveStatus(): string {
    return 'alive';
  }

  private getUptime(): number {
    return Math.floor((Date.now() - this.startTime) / 1000);
  }

  private getVersion(): string {
    return this.configService.get<string>('npm_package_version') || '1.0.0';
  }

  private async checkDatabase(): Promise<string> {
    try {
      const isConnected = await this.healthRepository.checkDatabase();
      return isConnected ? 'connected' : 'disconnected';
    } catch {
      return 'error';
    }
  }
}
</file>

<file path="src/user/dto/create-user.dto.ts">
import { IsEmail, IsOptional, IsEnum, IsString } from 'class-validator';
import { UserRole } from '../enums/user-role.enum';

export class CreateUserDto {
  @IsEmail()
  public email: string;

  @IsOptional()
  @IsString()
  public name?: string;

  @IsOptional()
  @IsEnum(UserRole)
  public role?: UserRole;
}
</file>

<file path="src/user/dto/index.ts">
export { CreateUserDto } from './create-user.dto';
export { UpdateUserDto } from './update-user.dto';
</file>

<file path="src/user/dto/update-user.dto.ts">
import { IsOptional, IsString, IsEnum } from 'class-validator';
import { UserRole } from '../enums/user-role.enum';

export class UpdateUserDto {
  @IsOptional()
  @IsString()
  public name?: string;

  @IsOptional()
  @IsEnum(UserRole)
  public role?: UserRole;
}
</file>

<file path="src/user/enums/user-role.enum.ts">
export enum UserRole {
  USER = 'USER',
  ADMIN = 'ADMIN',
  SUPER_ADMIN = 'SUPER_ADMIN',
}
</file>

<file path="src/user/interfaces/user.interface.ts">
import { UserRole } from '../enums/user-role.enum';

export interface User {
  id: string;
  email: string;
  name?: string;
  role: UserRole;
  created_at: Date;
  updated_at: Date;
}
</file>

<file path="src/user/user.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { UserController } from './user.controller';

describe('UserController', () => {
  let controller: UserController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UserController],
    }).compile();

    controller = module.get<UserController>(UserController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/user/user.controller.ts">
import { Controller } from '@nestjs/common';

@Controller('user')
export class UserController {}
</file>

<file path="src/user/user.module.ts">
import { Module } from '@nestjs/common';
import { UserController } from './user.controller';
import { UserService } from './user.service';

@Module({
  controllers: [UserController],
  providers: [UserService],
})
export class UserModule {}
</file>

<file path="src/user/user.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UserService],
    }).compile();

    service = module.get<UserService>(UserService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/user/user.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class UserService {}
</file>

<file path="src/app.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
</file>

<file path="src/app.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  public constructor(private readonly appService: AppService) {}

  @Get()
  public getHello(): string {
    return this.appService.getHello();
  }
}
</file>

<file path="src/app.module.ts">
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { validationSchema } from './config/env.validation';
import { configFactory } from './config/config.factory';
import { UserModule } from './user/user.module';
import { HealthModule } from './health/health.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      // In production, Azure injects Key Vault secrets as env vars
      // In development, use local .env file
      ignoreEnvFile: process.env.NODE_ENV === 'production',
      load: [configFactory],
      validationSchema,
      validationOptions: {
        allowUnknown: true,
        abortEarly: false,
      },
    }),
    UserModule,
    HealthModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</file>

<file path="src/app.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  public getHello(): string {
    return 'Hello World!';
  }
}
</file>

<file path="src/main.ts">
import { NestFactory } from '@nestjs/core';
import { Logger } from '@nestjs/common';
import { AppModule } from './app.module';
import { createLoggerConfig } from './config/logger.config';

function configureCors(
  app: Awaited<ReturnType<typeof NestFactory.create>>,
): void {
  app.enableCors({
    origin: process.env.CORS_ORIGIN || 'http://localhost:5173',
    credentials: true,
  });
}

function logStartupInfo(logger: Logger, port: string | number): void {
  logger.log(`Application is running on port ${port}`);
  logger.log(`Environment: ${process.env.NODE_ENV || 'development'}`);

  if (process.env.LOG_TO_FILE === 'true') {
    logger.log('File logging enabled - check logs/ directory');
  }
}

function handleStartupError(logger: Logger, error: unknown): void {
  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  logger.error('Failed to start application:', errorMessage);

  if (errorMessage?.includes('Validation')) {
    logger.error(
      'Configuration validation failed. Check your environment variables.',
    );
    logger.error(
      'In production, ensure Azure Key Vault secrets are properly configured.',
    );
  }

  process.exit(1);
}

async function bootstrap(): Promise<void> {
  const logger = new Logger('Bootstrap');

  try {
    logger.log('Starting NestJS application...');

    const app = await NestFactory.create(AppModule, {
      logger: createLoggerConfig(),
    });

    configureCors(app);

    const port = process.env.PORT ?? 3000;
    await app.listen(port);

    logStartupInfo(logger, port);
  } catch (error) {
    handleStartupError(logger, error);
  }
}

void bootstrap();
</file>

<file path="CLAUDE.md">
# USAsset Backend

## Overview
NestJS backend API configured for Azure Container Apps deployment with PostgreSQL database.

## Project Structure
```
src/
├── config/              # Configuration and validation
│   ├── config.factory.ts
│   ├── env.validation.ts
│   ├── env.validation.spec.ts
│   └── logger.config.ts
├── health/              # Health check endpoints
│   ├── health.controller.ts
│   ├── health.module.ts
│   └── health.service.ts
├── app.controller.ts    # Main app controller
├── app.module.ts        # Root module
├── app.service.ts       # Main app service
└── main.ts             # Application entry point
```

## Configuration

### Environment Variables
**Development** (.env file):
```bash
NODE_ENV=development
PORT=3000
DATABASE_URL=postgresql://dbadmin:password@localhost:5432/usasset
CORS_ORIGIN=http://localhost:5173
LOG_TO_FILE=false
```

**Production** (Azure Key Vault):
- `NODE_ENV=production` - Set in Container App
- `PORT` - Auto-set by Container Apps
- `DATABASE_URL` - From Key Vault: usasset-db-connection
- `CORS_ORIGIN` - Set in Container App config
- `JWT_SECRET` - From Key Vault: jwt-secret (REQUIRED)
- `API_KEY` - From Key Vault: api-key
- `LOG_TO_FILE=true` - Recommended for production

### Validation
- Joi schema validates all environment variables at startup
- Production requires: DATABASE_URL, JWT_SECRET
- Fails fast with clear error messages

### Logging
- Winston logger with NestJS integration
- Development: Colorized console output
- Production: JSON format for log aggregation
- Files: `logs/combined.log` and `logs/error.log`
- Never logs actual secrets (shows [SET]/[NOT SET])

## Available Scripts
```bash
npm run build           # Build for production
npm run start:dev       # Development server with hot reload
npm run start:dev:log   # Development with file logging
npm run start:prod      # Production server
npm run start:prod:log  # Production with file logging
npm run lint            # Run ESLint
npm run test            # Run unit tests
npm run test:e2e        # Run e2e tests
```

## Key Features
- ✅ NestJS ConfigModule with validation
- ✅ Azure Key Vault integration ready
- ✅ Health check endpoints (/health, /health/ready, /health/live)
- ✅ CORS configuration
- ✅ Winston file logging
- ✅ TypeScript with strict mode
- ✅ Jest testing setup
- ✅ ESLint configured

## Dependencies
- **Framework**: NestJS 11.x
- **Config**: @nestjs/config with Joi validation
- **Logging**: nest-winston, winston
- **Database**: Prisma (ready to connect)
- **Testing**: Jest

## Azure Deployment Notes
- Container Apps automatically injects Key Vault secrets as env vars
- Health checks configured for Container Apps probes
- Logs can be streamed to Azure Monitor
- PORT is automatically set by Container Apps

## Testing
```bash
npm test                        # All tests
npm test env.validation         # Config validation tests
npm run test:e2e -- config      # Config e2e tests
```

## Common Tasks

### Add a new module
```bash
nest g module feature-name
nest g controller feature-name
nest g service feature-name
```

### Check configuration
```bash
LOG_TO_FILE=true npm run start:dev
# Then check logs/combined.log for config output
```

### Validate environment
```bash
NODE_ENV=production npm run start:prod
# Will fail with clear message if required vars missing
```
</file>

<file path="Dockerfile">
# Build stage
FROM node:20-alpine AS builder

# Fix for Prisma hanging - use correct Alpine target
ENV PRISMA_CLI_BINARY_TARGETS=linux-musl-openssl-3.0.x

WORKDIR /app

COPY package*.json ./
RUN npm install
COPY prisma ./prisma/
RUN npx prisma generate

COPY . .
RUN npm run build

# Production stage
FROM node:20-alpine AS production

# Install netcat for database health check
RUN apk add --no-cache netcat-openbsd

WORKDIR /app

COPY package*.json ./
# Need full dependencies including Prisma CLI for migrations
RUN npm install --production && npm install prisma

# Copy built files
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/generated ./generated

# Copy Prisma files for migrations
COPY prisma ./prisma

# Copy and set permissions for entrypoint
COPY docker-entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh

EXPOSE 3000

ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["node", "dist/main.js"]
</file>

<file path="eslint.config.mjs">
// @ts-check
import eslint from '@eslint/js';
import eslintPluginImport from 'eslint-plugin-import';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginImport.flatConfigs.recommended,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
    settings: {
      'import/resolver': {
        typescript: {
          alwaysTryTypes: true,
          project: './tsconfig.json',
        },
      },
    },
  },
  {
    rules: {
      // === COMPLEXITY BUDGET RULES (CLAUDE.md principles) ===
      // "If you can't explain it in one sentence, it's too complex"
      'complexity': ['error', { max: 7 }],
      // "Each method has max 20-30 lines"
      'max-lines-per-function': ['error', { max: 30, skipBlankLines: true, skipComments: true }],
      // Limit statements per function to keep methods focused
      'max-statements': ['error', 15],
      // Limit nesting depth to prevent complex branching
      'max-depth': ['error', 3],
      // "Each service has max 3-5 public methods" - limit parameters supports this
      'max-params': ['error', 4],
      
      // === NO CLEVER CODE RULES (Explicit over implicit) ===
      // Force explicit return types - no implicit any
      '@typescript-eslint/explicit-function-return-type': 'error',
      // Prevent any types - must be explicit
      '@typescript-eslint/no-explicit-any': 'error',
      // Force explicit variable declarations
      'prefer-const': 'error',
      // Prevent floating promises
      '@typescript-eslint/no-floating-promises': 'error',
      // Prevent unsafe arguments
      '@typescript-eslint/no-unsafe-argument': 'error',
      // Force explicit member accessibility
      '@typescript-eslint/explicit-member-accessibility': ['error', { accessibility: 'explicit' }],
      
      // === DEPENDENCY MANAGEMENT (Shallow dependencies) ===
      // Prevent circular dependencies between features
      'import/no-cycle': 'error',
      // Prevent self-imports
      'import/no-self-import': 'error',
      
      // === ONE THING PER FILE ENFORCEMENT ===
      // Prevent multiple classes per file
      'max-classes-per-file': ['error', 1],
      
      // === CLEAN CODE PATTERNS ===
      // Force consistent code patterns
      '@typescript-eslint/consistent-type-definitions': ['error', 'interface'],
      // Prevent unused variables (clean up)
      '@typescript-eslint/no-unused-vars': 'error',
      // Force consistent naming
      '@typescript-eslint/naming-convention': [
        'error',
        {
          selector: 'interface',
          format: ['PascalCase']
        },
        {
          selector: 'class',
          format: ['PascalCase']
        },
        {
          selector: 'method',
          format: ['camelCase']
        }
      ],
    },
  },
);
</file>

<file path="nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:dev:log": "LOG_TO_FILE=true nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "start:prod:log": "LOG_TO_FILE=true node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "typecheck": "tsc --noEmit",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:deploy": "prisma migrate deploy",
    "db:studio": "prisma studio",
    "db:reset": "prisma migrate reset",
    "db:seed": "prisma db seed",
    "azure:prebuild": "npx prisma generate",
    "azure:deploy": "prisma migrate deploy && npm run start:prod"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/platform-express": "^11.0.1",
    "@prisma/client": "^6.15.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "joi": "^18.0.1",
    "nest-winston": "^1.10.2",
    "prisma": "^6.15.0",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@swc/cli": "^0.6.0",
    "@swc/core": "^1.10.7",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-import-resolver-typescript": "^4.4.4",
    "eslint-plugin-import": "^2.32.0",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^29.7.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
</file>

<file path="repomix.config.json">
{
  "output": {
    "filePath": "./repomix-backend-output.xml"
  },
  "include": [
    "src/**/*",
    "prisma/**/*",
    "generated/prisma/index.d.ts",
    "generated/prisma/client.d.ts",
    "*.json",
    "*.md",
    "Dockerfile",
    "*.config.*",
    "*.ts",
    "*.js"
  ],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": [
      "dist/**",
      "node_modules/**",
      "*.log",
      "generated/prisma/*.js",
      "generated/prisma/runtime/**",
      "generated/prisma/lib*"
    ]
  },
  "security": {
    "enableSecurityCheck": true
  }
}
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}
</file>

</files>
